## 💻 Section 0 - 컨벤션. (Applied Conventions for js & commit(git) + self manual for second_week mission).

<br>

## js 코드 컨벤션: [우테코 프리코스 코드 컨벤션](https://github.com/woowacourse/woowacourse-docs/tree/main/styleguide/javascript), [에어비엔비 자바스크립트 코드 컨벤션](https://github.com/airbnb/javascript).

<br>

**참고한 인사이트**: [1주차 미션 피드백](https://docs.google.com/document/d/1fxW5IrWeJ6VATWJqE9F5NDiRifrqLRsChXFVicVEQdw/edit#).

**추가된 요구 사항:**

- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.

  - 예를 들어 while문 안에 if문이 있으면 들여쓰기는 2이다.
  - indent(인덴트, 들여쓰기) depth를 줄이는 좋은 방법은 함수(또는 메소드)를 분리하면 된다.

- 함수(또는 메소드)가 한 가지 일만 하도록 최대한 작게 만들어라.
- Jest를 이용하여 본인이 정리한 기능 목록이 정상 동작함을 테스트 코드로 확인한다.
  - 테스트 도구 사용법이 익숙하지 않다면 **tests**/StringTest.js를 참고하여 학습한 후 테스트를 구현한다.

++ **추가로 적용 해본 내용**

- 변수 선언시 var 를 사용하지 않는다. const 와 let 을 사용한다.
- 함수(또는 메소드)의 길이가 15라인을 넘어가지 않도록 구현한다.
  - 함수(또는 메소드)가 한 가지 일만 잘 하도록 구현한다.

<br>

## 커밋 컨벤션:

> ### 커밋 메시지 구조

<pre>커밋 타입: 제목(커밋 로그 타이틀)     
바디(옵션)             </pre>
  <br>

🍎 chore: 자잘한 수정 <br>
📄 docs: 문서 관련 <br>
🖊 feat: 새로운 기능, 페이지 추가 <br>
🎨 style: 코드 포맷팅, 세미콜론 누락 등 코드 자체의 변경이 없는 경우 <br>
🐞 fix: 버그 수정 <br>
💡 refactor: 코드 리팩토링 <br>
🧪 test: 테스트 관련 <br>

<br>

## SELF MANUAL

#### 0. 변경 사항, 및 수정 시 항상 add - commit을 함께 진행해준다. (README.md - 커밋 컨벤션에 fit하게 커밋 로그 작성)

#### 1. 기능 구현에 들어가기 전, 각 문항별로 기능을 정의해본다. -> README.md 파일에 명세한다.

#### 2. 기능 단위로 코드를 작성하고 add - commit을 진행한다. (커밋 컨벤션에 맞게 커밋 로그 작성)

#### 3. 전체 코드를 작성한 후에 npm test를 통해 예외 상황을 포함한 모든 test case들에 빠짐없이 잘 동작하는지 체크해본다.

#### 4. 해당 코드가 README.md 파일의 "구현시 적용할 내용"에 fit 하는지 체크한다. -> 문제가 있는 부분은 수정한다.

#### 5. 완성 후에 각각 기능 단위로 설명을 담은 주석을 붙여준다. -> 커밋 로그 작성. (add - commit / 커밋 컨벤션에 맞게!)

#### 6. 코드를 작성할 때 미처 적용하지 못한 [에어비엔비 자바스크립트 코드 컨벤션](https://github.com/airbnb/javascript)이 있는지 검사해보고, 컨벤션과 다른 부분들을 컨벤션에 맞게 수정해준다.

<br>

<hr>

## ⚙️ Section 1 - 문제 정의 / 구현할 기능 목록.

> ## 접근 방식.

이번엔, 다양한 테스트 케이스들을 기반으로 한 개발론. [테스트 주도 개발(TDD)](https://ko.wikipedia.org/wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8_%EC%A3%BC%EB%8F%84_%EA%B0%9C%EB%B0%9C)방법을 적용해서 개발해보고자 했다.

### why [TDD](https://ko.wikipedia.org/wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8_%EC%A3%BC%EB%8F%84_%EA%B0%9C%EB%B0%9C)?

1주차 미션 진행에 있어 원래 계획에 실패한 가장 큰 이유가 바로 '시간 부족'이었다. <br>
미션 수행 중 가장 크게 시간을 소모시킨 부분이 바로 **예외 케이스들에 처리** + **각 문제들에 대해 사전에 정확하게 정의 내리지 않았기 떄문**이다. <br>
-> 때문에 TDD 방식으로 문제를 사전에 정의 내리고 기능에 대한 명세를 보다 구체적으로 할 수 있다면 <br>
1주차 미션 해결 과정중에 발생했던 다양한 이슈들을 **예방**해 줄 수 있는 방법이라고 생각이 들었다.

### 기능 목록.

1. 입력값을 받고, 다른 여러 메소드들을 호출해서 연결시키는 메인 메소드 play.
2. 생성자 메소드. (시작 코멘트 출력, 정답 생성)
3. 입력값이 올바른지 검사 해주는 기능. (예외 상황에 대한 처리)
4. 정답 생성(1~9의 랜덤한 3자리 수).
5. 입력값을 가지고 정답과 비교해 "스트라이크 / 볼 / 낫싱"을 검사 및 출력 하는 기능.
6. 게임 종료 조건이 충족되면, 게임 종료 멘트 출력. -> 재시작 / 프로그램 종료에 대한 입력값을 받고 해당 값에 맞게 동작하게 해주는 기능.

<br>

## ⚾️ Section 2 - 야구 게임 프로그램 구현 기능 목록 상세화 시켜보기.

1. 사용자가 잘못된 값을 입력한 경우에 대한 처리를 담당하는 기능이다. 야구 게임은 3 자리수를 기점으로 게임 메커니즘이 돌아가는데, 1자리수 혹은 2자리수 등 3 자리수가 아닌 수의 경우 + 1~9를 제외한 모든 기타 등등의 입력값(문자열, 특수 문자 등) + 중복된 수가 들어오는 경우를 체크해서, 하나라도 잘 못 되었을 경우 false 값을 반환해준다.

2. 사용자가 입력한 숫자를 '볼' / '스트라이크'/ '낫싱'이라는 조건으로 검사해서 충족하는 내용을 반환해주는 기능이다. 스트라이크 검사 기능 메소드와 볼 검사 기능 메소드를 호출해서 볼과 스트라이크의 갯수를 알아낸다. -> 알아낸 두 개의 수를 바탕으로 사용자에게 보여줄 힌트를 문자열로 담아서 반환해준다. 또한, 스트라이크의 개수가 3개인지 검사해서 만약 3 스트라이크로 컴퓨터의 랜덤 한 세자리 수를 모두 맞췄다면, 게임이 끝났다는 내용을 boolean 형식으로 담아놓았다가 힌트와 함께 배열 형태로 반환해준다.

3. 입력값에 '볼'이 있는지 검사해주는 기능으로, 컴퓨터에서 뽑아낸 3자리의 랜덤한 수와 사용자가 입력한 값을 비교해서 수의 자리는 다르지만 값은 일치하는 수가 있는지 검사한다. -> 여기서 중요한 점은 **수의 자리는 다르고, 값만 같다는 조건**이어야 한다는 점이다. 해당 조건에 맞는 수의 갯수만큼 카운트해서 반환해준다.

4. 입력값에 '스트라이크'가 있는지 검사해주는 기능으로, 컴퓨터에서 뽑아낸 3자리의 랜덤한 수와 사용자가 입력한 값을 비교해서 수의 자리와 값까지 일치하는 수가 있는지 검사한다. -> 해당 조건을 만족하는 수의 개수를 반환해준다.

5. 컴퓨터의 랜덤 수이자 게임의 정답을 생성해주는 기능으로, 중복되지 않는 임의의 1 ~ 9 사이의 수로 이루어진 세자리 수를 만들어서 반환해준다.

6. 게임의 전반적인 프로세스를 관리하는 메인 로직 기능으로, 사용자에게 숫자를 입력받아 -> 해당 숫자가 올바른 값인지 체크해주는 메소드를 호출한다. 올바르지 않은 값이라면 throw 문을 사용해 예외를 발생시킨후 애플리케이션을 종료한다. -> 올바른 값이라면 2번 메소드를 호출해서 사용자에게 보여줄 출력 값(힌트)과 게임을 계속 진행해도 되는지 여부를 받아온다. -> 사용자에게 힌트를 출력해주고, 만약 받아온 값 중 게임이 끝났다는게 true 값이라면, 게임을 종료하는 메소드를 호출 / 그게 아니라면 다시 자기 자신을 호출해줘서 다음 숫자값을 입력받을 수 있도록 한다.

7. 게임이 정상적으로 종료되었을 때(스트라이크 갯수 === 3) 호출되는 메소드로 엔딩 멘트를 출력해주고, 게임을 재시작할지 아예 종료할지 1 or 2로 사용자에게 입력값을 받는다. 재시작 명령어인 1이 입력되면 재시작 메소드를 호출해주고, 다른 값이 입력되면 프로그램을 종료한다.

8. 게임 재시작이 입력되었을 때 호출되는 메소드로 정답(컴퓨터의 랜덤 수)을 새로운 값으로 초기화시켜주고, 6번 메인 메소드인 play를 호출해준다.

9. 게임이 시작되었을 때 생성자 함수에 의해 최초로 호출되는 메소드로, 오프닝 멘트("숫자 야구 게임을 시작합니다.")를 출력해준다.

10. 생성자 함수로, 9번 메소드를 호출해서 오프닝 멘트를 출력해주고, 5번 메소드를 호출해서 정답(컴퓨터의 랜덤 수)을 초기화 시켜준다.

<br>

## ➗ Section 3 - 야구 게임 프로그램 구현 기능 목록 모듈화.

Section 2에서 구현한 기능 목록들을 각각의 정체성들에 맞게 다음과 같이 세 가지의 파일로 나누어보았다.

1. 순수 게임 실행 관련 메소드들. (게임 시작 / 사용자로부터 직접적인 입력 값을 받고, 일정 조건들에 따라 게임 진행 / 게임 종료 / 재시작 등의 게임 실행 관련 기능들)

2. 게임 실행에 필요한 로직 기능 수행 메소드들. (낫싱 / 볼 / 스트라이크 갯수 체크 및 힌트 메시지 생성 기능)

3. 로직과 상관 없는 정적 형태의 게임 자원 메소드들. (맞는 형식인지 체크 기능 for 예외처리 / 랜덤한 1~9 세자리 수 생성 기능)

<br>

## 🧪 Section 4 - 테스트 케이스 추가. (구현한 로직에 맞춤형으로 여러 케이스들 체크)

게임이 정상적으로 종료 된 이후에, 게임의 재시작과 종료 사이에서 잘 못 눌렀을 경우 다시 1, 2번 버튼을 입력할 수 있게 로직을 구현해 두었다.
이 부분은 요구사항에 명세되어 있지 않았던 부분이라 알아서 판단하여 구현한 기능인 만큼, 테스트 케이스에 추가를 해 잘 돌아가는지 확인하면서 진행하였다.

최대한 TDD 기반으로 개발을 진행하려고 했던 만큼, 기존 케이스에 포함되지 않은 내용들을 하나하나 넣어보면서 예외 처리 / 정상적인 값일 때의 경우의 수 세분화 / 게임 종류 이후의 예외처리 까지 꼼꼼하게 체크하면서 개발을 진행해볼 수 있었다.
